#!/usr/bin/env python3

import gym
import numpy as np
from gym.envs import KG_env
from gym.error import DependencyNotInstalled
from learn2learn.gym.envs.meta_env import MetaEnv

class KG_task_env(MetaEnv,KG_env):
    def __init__(self, task_meta = None):
        MetaEnv.__init__(self, task)
        

    # -------- MetaEnv Methods --------
    def set_task(self, task):
        MetaEnv.set_task(self, task)
        self.goal_direction = task['direction']

    def sample_tasks(self, num_tasks):
        choice_relations  = np.random.choice(np.arange(0,400,1, dtype=int), (num_tasks,))
        tasks = [{'direction': direction} for direction in directions]
        return tasks
    
  ##-------------GYM methods------------   
    def idx_state(self, idx_list):
		if idx_list != None:
			curr = self.entity2vec[idx_list[0],:]
			targ = self.entity2vec[idx_list[1],:]
			return np.expand_dims(np.concatenate((curr, targ - curr)),axis=0)
		else:
			return None	
		
		
		
		
	def reset(self, *,dataPath,kb,kb_inv, seed: Optional[int] = None,options: Optional[dict] = None)
		super.reset(seed=seed)
		#Call env.make before this 
		#Call gym.make(datapath,train[i_episode])
                f = open(dataPath_ + '/train.pairs')
	        train_data = f.readlines()
	        f.close()
	        train_pairs = []
	
	       for line in train_data:
		e1 = line.split(',')[0].replace('thing$','')
		e2 = line.split(',')[1].split(':')[0].replace('thing$','')
		if (e1 not in kb.entities) or (e2 not in kb.entities):
			continue
		train_pairs.append((e1,e2))
		label = 1 if line[-2] == '+' else 0
		sample = train_pairs.split()
		state_idx = [env.entity2id_[sample[0]], env.entity2id_[sample[1]], 0]
        	self.state = self.idx_state(state_idx)
		self.steps_beyond_terminated = None
		return np.array(self.state,dtype = np.float32),{}
	

	def step(self, action):
		assert self.action_space.contains(action), f"{action!r} ({type(action)}) invalid"
		assert self.state is not None, "Call reset before using step method."
		terminated = 0 # Whether the episode has finished
		curr_pos, target_pos,0 = self.state
		chosed_relation = self.relations[action]
		choices = []
		for line in self.kb:
			triple = line.rsplit()
			e1_idx = self.entity2id_[triple[0]]
			
			if curr_pos == e1_idx and triple[2] == chosed_relation and triple[1] in self.entity2id_:
				choices.append(triple)
		if len(choices) == 0:
			reward = -1
			self.die += 1
			self.state = (curr_pos, target_pos, self.die) # stay in the initial state
			return np.array(self.state,dtype=np.float32),reward, terminated, False, {}
		else: # find a valid step
			path = random.choice(choices)
			self.path.append(path[2] + ' -> ' + path[1])
			self.path_relations.append(path[2])
			# print('Find a valid step', path)
			# print('Action index', action)
			self.die = 0
			new_pos = self.entity2id_[path[1]]
			reward = 0
			self.state = (new_pos, target_pos, self.die)

			if new_pos == target_pos:
				print('Find a path:', self.path)
				terminated = 1
				reward = 1
				self.state = None
			return np.array(self.state,dtype=np.float32),reward, terminated, False, {}


	def get_valid_actions(self, entityID):
		actions = set()
		for line in self.kb:
			triple = line.split()
			e1_idx = self.entity2id_[triple[0]]
			if e1_idx == entityID:
				actions.add(self.relation2id_[triple[2]])
		return np.array(list(actions))

	def path_embedding(self, path):
		embeddings = [self.relation2vec[self.relation2id_[relation],:] for relation in path]
		embeddings = np.reshape(embeddings, (-1,embedding_dim))
		path_encoding = np.sum(embeddings, axis=0)
		return np.reshape(path_encoding,(-1, embedding_dim))


if __name__ == '__main__':
    env = AntForwardBackwardEnv()
    for task in [env.get_task(), env.sample_tasks(1)[0]]:
        env.set_task(task)
        env.reset()
        action = env.action_space.sample()
        env.step(action)
